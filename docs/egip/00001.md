# EIP-00001: ECALL in Solidity and AVM

| Author   | ieigen-max, weber      |
| -------- | ---------------------- |
| Status   | Developing             |
| Type     | Private Smart Contract |
| Category | Core                   |
| Created  | 2021-05-20             |

[toc]

## Simple Summary

To provide external call from Solidity and AVM

## Abstract

By adding a new built-in function in Solidity and AVM to support different privacy computing protocol on Layer2

## Motivation

Enhance the privacy of smart contract by EigenCC or EigenFL.

## Specification

### API spec
1. Function signature

   ```solidity
   function eigenCall(uint256 arg1, uint256 arg2, uint256 arg3, uint256 arg4) external pure returns (uint256, uint256, uint256, uint256);
   ```

2. Input

   * `arg1`, `arg2`, `arg3`, `arg4`: 4 input arguments
   * `arg1` represents the kind of operator. For now, we have implemented:
     - `0`: `EigenTEERegister` operator, register keys in TEE
     - `1`: `add` operator, adds two ciphers, if success, returns the result which is also a cipher
     - `2`: `add1` operator, add a cipher to a number which is a plaintext, if success, returns the result which is also a cipher
     - `3`: `sub` operator, a cipher subs a cipher, if success, returns the result which is also a cipher
     - `4`: `sub1` operator, a cipher subs a number which is a plaintext, if success, returns the result which is also a cipher
     - `11`: `enc` operator, encrypt a number into a cipher, if success, returns the the cipher
     - `12`: `dec` operator, decrypt a cipher into a number, if success, returns the the number
3. Returns

   * `out_arg1`, `out_arg2`, `out_arg3`, `out_arg4`: 4 output arguments
   * `out_arg1` represents if the calling of operator is success:
     - `0`: Success
     - `1`: Fail
   * `out_arg2` represents the result of the operator

### Example snippet

This snippet should work without fire the `require`:
```solidity
// ...

uint256[4] memory out_args ;

// Enc 100
(out_args[0], out_args[1], out_args[2], out_args[3]) = ArbSys(address(100)).eigenCall(11, 100, 0, 0);
require(out_args[0] == 0);
uint256 enc_num_1 = out_args[1];

// Enc 1
(out_args[0], out_args[1],out_args[2], out_args[3]) = ArbSys(address(100)).eigenCall(11, 1, 0, 0);
require(out_args[0] == 0);
uint256 enc_num_2 = out_args[1];

// Add
(out_args[0], out_args[1],out_args[2], out_args[3]) = ArbSys(address(100)).eigenCall(1, enc_num_1, enc_num_2, 0);
require(out_args[0] == 0);
uint256 enc_add_cipher = out_args[1];

// Dec 
(out_args[0], out_args[1],out_args[2], out_args[3]) = ArbSys(address(100)).eigenCall(12, enc_add_cipher, 0, 0);
require(out_args[0] == 0);
uint256 expect = out_args[1];

// The decrypted result should be 101 (100 + 1)
require(expect == 101);

// ...
```

### Dispute Assertion
The eigenCall is executed off the chain as a kind of secure out-soured computing. While outsourcing, the computing power provider, namely prover, will generate a signature in TEE or a ZKP in Non-TEE, 
as the OneStepProof.

## Rationale

## Backwards Compatibility

## TestCases

## Implementation

## Tests

## Copyright
