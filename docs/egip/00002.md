# EIP-00002: Confidential Contract

| Author   | eigmax |
| -------- | ---------------------- |
| Status   | Finished |
| Type     | Private Smart Contract |
| Category | Core                   |
| Created  | 2021-06-22             |

[toc]

## Abstract

This proposal aims to provide confidential operator implementation specification.

## Motivation

Depends on the [EGIP 00001](https://github.com/ieigen/ieigen/blob/main/docs/egip/00001.md), It's possible, but not very easy to implement confidential business logic in contract.  This proposal introduced a specification to declare and define confidential operators.

## Specification

The framework [EigenCC](https://github.com/ieigen/ieigen/tree/main/cc) provides an [easy way](https://github.com/ieigen/ieigen/blob/main/docs/operators.md) to add new instruction in trusted execution environment(TEE).  We focus on 2 important parts to leverage the confidential trusted computing environment.

* Confidential operators:  what operators inside TEE can be provided and how it get done;
* Secure transportation: how the privacy information is sent or received from the Eigen Network without privacy breach;
* On-chain data protection: how we store the privacy information on chain.

### Confidential operators

What we need the most is:

*  Three arithmetic operators:  addition, subtraction and multiplication on 256bits integer
* Comparison operators:  greater than, less than and equal
* Debug operators:  encryption and decryption

As we mentioned on EGIP 00001, we use format as below to describe an input of `eigenCall`:

```
operator||num_of_args,arg1,arg2,arg3
```

Operator is the name of above operators, and 9 operators have provided:

| Operator              | Args           | Description                                                  |
| --------------------- | -------------- | ------------------------------------------------------------ |
| add_cipher_cipher     | [opr1], [opr2] | sum two encrypted numbers                                    |
| add_cipher_plain      | [opr1], opr2   | sum an encrypted number and a plain number                   |
| sub_cipher_cipher     | [opr1], [opr2] | subtract one encrypted numbers by another                    |
| sub_cipher_plain      | [opr1], opr2   | subtract the plain number from encrypted big numbers         |
| compare_cipher_cipher | [opr1], [opr2] | Compare  two encrypted numbers                               |
| compare_cipher_plain  | [opr1], opr2   | Compare encrypted number to plain number, returns -1, 0, and 1, responding to less than , equals  and greater than |
| re_encrypt            | [opr1], [opr2] | The first argument is encrypted AES secret, and the second is the encrypted number.  The result is the re-encryped number by AES secret.  It's usually used when user try to query the privacy information from confidential smart contract. The key size is 32 bytes. |
| encrypt               | opr1           | For DEBUG, encrypt a plain                                   |
| decrypt               | [opr1]         | For DEBUG, decrypt a cipher                                  |

### Secure transportation

Referring to the security mechanism of TLS, we adopt the [RA-TLS](https://arxiv.org/pdf/1801.05863.pdf) schema for the a secure channel between end-user and EigenCC. The general workflow is like below:

![ra-tls](https://github.com/ieigen/ieigen/raw/main/docs/images/ra-tls.png)

The main updates is we put the Enclave Quote embedded to X509 certificate, and the challenger verifies the quote after the general certificate verification.

In our implementation, we provide a socket-based channel between EGVM(AVM) and EigenCC.

Hence, all above encrypted item are encrypted by an ECC public key with [ECIES](https://github.com/ieigen/ieigen/blob/main/l2/eigen_service/src/ecies.ts).  When EigenCC launches, it will generate an ECC key pair, and the public key will be registered to [PKCS](https://github.com/ieigen/ieigen/tree/main/l2/eigen_service#pkcs). 

### On-chain data protection

This is a tough issue. Since the on-chain data  is openly accessed by anyone, if a vulnerable logic or weak key was used, it leads all the privacy inside the corresponding contract will be exposed to everyone. Hence, how to encrypt the on-chain data becomes crucial.  

It recommends to take the secret key into custody by the owner itself, and use  `re_encrypt` to encrypt the privacy information, and upgrades the key periodically.

## Rationale

It aims to provide pricy and most compatible privacy protection schema for on-chain privacy computing.

## Backwards Compatibility

## TestCases

All tests for confidential operators can be found at [demo.ts](https://github.com/ieigen/ieigen/blob/main/l2/eigen-tutorials/packages/confidential-contracts/tests/demo.ts).

## Implementation

Confidential ERC20 had been implemented at [TestCCCustomToken.sol](https://github.com/ieigen/ieigen/blob/main/l2/eigen-tutorials/packages/confidential-contracts/contracts/tokenbridge/test/TestCCCustomToken.sol).  the coming confidential contract will be AMM-based DEX.

## Tests

## Copyright
