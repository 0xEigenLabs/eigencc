# EIP-00002: Confidential Contract

| Author   | eigmax                 |
| -------- | ---------------------- |
| Status   | Designing              |
| Type     | Private Smart Contract |
| Category | Core                   |
| Created  | 2021-06-22             |

[toc]

## Abstract

This proposal aims to provide confidential operator implementation specification.

## Motivation

Depends on the [EGIP 00001](https://github.com/ieigen/ieigen/blob/main/docs/egip/00001.md), It's possible, but not very easy to implement confidential business logic in contract. This proposal introduced a specification to declare and define confidential operators.

## Specification

The framework [EigenCC](https://github.com/ieigen/ieigen/tree/main/cc) provides an [easy way](https://github.com/ieigen/ieigen/blob/main/docs/operators.md) to add new instruction in trusted execution environment(TEE). We focus on 2 important parts to leverage the confidential trusted computing environment.

- Confidential operators: what operators inside TEE can be provided and how it get done;
- Secure transportation: how the privacy information is sent or received from the Eigen Network without privacy breach;
- On-chain data protection: how we store the privacy information on chain.

### Confidential operators

What we need the most is:

- Three arithmetic operators: addition, subtraction and multiplication on 256bits integer
- Comparison operators: greater than, less than and equal
- Debug operators: encryption and decryption

As we mentioned on EGIP 00001, we use format as below to describe an input of `eigenCall`:

```
operator||num_of_args,arg1,arg2,arg3
```

Operator is the name of above operators, and 9 operators have provided:

| Operator              | Args           | Description                                                                                                                                                                                                                                                          |
| --------------------- | -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| add_cipher_cipher     | [opr1], [opr2] | sum two encrypted numbers                                                                                                                                                                                                                                            |
| add_cipher_plain      | [opr1], opr2   | sum an encrypted number and a plain number                                                                                                                                                                                                                           |
| sub_cipher_cipher     | [opr1], [opr2] | subtract one encrypted numbers by another                                                                                                                                                                                                                            |
| sub_cipher_plain      | [opr1], opr2   | subtract the plain number from encrypted big numbers                                                                                                                                                                                                                 |
| compare_cipher_cipher | [opr1], [opr2] | Compare two encrypted numbers                                                                                                                                                                                                                                        |
| compare_cipher_plain  | [opr1], opr2   | Compare encrypted number to plain number, returns -1, 0, and 1, responding to less than , equals and greater than                                                                                                                                                    |
| re_encrypt            | [opr1], [opr2] | The first argument is encrypted AES secret, and the second is the encrypted number. The result is the re-encryped number by AES secret. It's usually used when user try to query the privacy information from confidential smart contract. The key size is 32 bytes. |
| encrypt               | opr1           | For DEBUG, encrypt a plain                                                                                                                                                                                                                                           |
| decrypt               | [opr1]         | For DEBUG, decrypt a cipher                                                                                                                                                                                                                                          |

### Secure transportation

Referring to the security mechanism of TLS, we adopt the [RA-TLS](https://arxiv.org/pdf/1801.05863.pdf) schema for the a secure channel between end-user and EigenCC. The general workflow is like below:

![ra-tls](https://github.com/ieigen/ieigen/raw/main/docs/images/ra-tls.png)

The main updates is we put the Enclave Quote embedded to X509 certificate, and the challenger verifies the quote after the general certificate verification.

In our implementation, we provide a socket-based channel between EGVM(AVM) and EigenCC.

Hence, all above encrypted item are encrypted by an ECC public key with [ECIES](https://github.com/ieigen/ieigen/blob/main/l2/eigen_service/src/ecies.ts). When EigenCC launches, it will generate an ECC key pair, and the public key will be registered to [PKCS](https://github.com/ieigen/ieigen/tree/main/l2/eigen_service#pkcs).

### On-chain data protection

This is a tough issue. Since the on-chain data is openly accessed by anyone, if a vulnerable logic or weak key was used, it leads all the privacy inside the corresponding contract will be exposed to everyone. Hence, how to encrypt the on-chain data becomes crucial.

It recommends to take the secret key into custody by the owner itself, and use `re_encrypt` to encrypt the privacy information, and upgrades the key periodically.

## Rationale

It aims to provide pricy and most compatible privacy protection schema for on-chain privacy computing.

## Backwards Compatibility

## TestCases

All tests for confidential operators can be found at [demo.ts](https://github.com/ieigen/ieigen/blob/main/l2/eigen-tutorials/packages/confidential-contracts/tests/demo.ts).

## Implementation

Confidential ERC20 had been implemented at [TestCCCustomToken.sol](https://github.com/ieigen/ieigen/blob/main/l2/eigen-tutorials/packages/confidential-contracts/contracts/tokenbridge/test/TestCCCustomToken.sol). the coming confidential contract will be AMM-based DEX.
To make it easy use and save gases, we implement a link library named `EigenCallLibrary` [here](https://github.com/ieigen/ieigen/blob/main/l2/eigen-tutorials/packages/confidential-contracts/contracts/tokenbridge/libraries/EigenCallLibrary.sol). It can be deployed on L2 and anyone can call them if deployed with the address.
`EigenCallLibrary` is implemented based on [EGIP 00001](https://github.com/ieigen/ieigen/blob/main/docs/egip/00001.md), for now, we have implemented these public functions:

```solidity
/**
  * @dev Encrypt a plain number
  * @param plain The number we want to encrypt
  * @return The cipher.
  */
function encrypt(uint256 plain) public pure returns (bytes memory);

/**
  * @dev Decrypt a cipher
  * @param cipher The cipher we want to decrypt
  * @return The decrypted number, which is ascii string
  */
function decrypt(bytes memory cipher) public pure returns (bytes memory);

/**
  * @dev Add 2 ciphers
  * @param cipher1 The first cipher
  * @param cipher2 The second cipher
  * @return The decrypted result.
  */
function addCipherCipher(bytes memory cipher1, bytes memory cipher2)
        public
        pure
        returns (bytes memory);

/**
  * @dev Add a cipher to a plain number
  * @param cipher The cipher
  * @param plain The plain number
  * @return The decrypted result.
  */
function addCipherPlain(bytes memory cipher, uint256 plain) public pure returns (bytes memory);

/**
  * @dev Substract a cipher with a cipher
  * @param cipher1 The cipher of minuend
  * @param cipher2 The cipher of subtrahend
  * @return The decrypted result.
  */
function subCipherCipher(bytes memory cipher1, bytes memory cipher2)
    public
    pure
    returns (bytes memory);

/**
  * @dev Substract a cipher with a plain number
  * @param cipher The cipher of minuend
  * @param plain The plain number of subtrahend
  * @return The decrypted result.
  */
function subCipherPlain(bytes memory cipher, uint256 plain) public pure returns (bytes memory);

/**
  * @dev Compare a cipher with a cipher
  * @param cipher1 The 1st cipher
  * @param cipher2 The 2nd cipher
  * @return The compare result, -1 if cipher1 < cipher2, 1 if cipher1 > cipher2, 0 if they are equal
  */
function compareCipherCipher(bytes memory cipher1, bytes memory cipher2)
    public
    pure
    returns (int256);

/**
  * @dev Compare a cipher with a plain number
  * @param cipher The cipher
  * @param plain The plain number
  * @return The compare result, -1 if cipher < plain, 1 if cipher > plain, 0 if they are equal
  */
function compareCipherPlain(bytes memory cipher, uint256 plain) public pure returns (int256);

/**
  * @dev Re-encrypt a cipher with a secret
  * @param secret The secret we want to use to re-encrypt
  * @param cipher The cipher number
  * @return The decrypted result.
  */
function reEncrypt(bytes memory secret, bytes memory cipher)
    public
    pure
    returns (bytes memory);

/**
  * @dev A utility function which is used for copying bytes
  * @param src The source bytes we want to copy
  * @return A new bytes which are equal to src
  */
function copyBytes(bytes memory src) public pure returns (bytes memory);
```

These functions hidden the details of implementations of `eigenCall`, so the user do not care about how to compose a `eigenCall` input bytes, or how to decode the returning RLP encoded value. A `assert` is put into each wrapper functions to ensure `eigenCall` is called successfully. If any error occurs, the contract call will cause transaction revert with a message.

## Tests

## Copyright
